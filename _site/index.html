<!DOCTYPE html> <html> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> watermint.org &middot; Takayuki Okazaki's note </title> <link rel="stylesheet" href="/public/watermint.css"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/watermint-logo.png"> <link rel="shortcut icon" href="/public/watermint-logo.png"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> </head> <body class="theme-base-09"> <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"> <div class="sidebar" id="sidebar"> <div class="sidebar-item"> <p>Travel, camera, photo, and technical things. I work at Dropbox. Thoughts are my own.</p> </div> <nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/">Home</a> <a class="sidebar-nav-item" href="/about/">About</a> <a class="sidebar-nav-item" href="/atom.xml">Feed</a> <a class="sidebar-nav-item" href="https://github.com/watermint">Github</a> <a class="sidebar-nav-item" href="https://www.instagram.com/watermint/">Instagram</a> </nav> <div class="sidebar-item"> <p> &copy; 2005-2017 Takayuki Okazaki </p> </div> </div> <div class="wrap"> <div class="masthead"> <div class="container"> <h3 class="masthead-title"> <a href="/" title="Home">watermint.org</a> <small>- Takayuki Okazaki's note</small> </h3> </div> </div> <div class="container content"> <div class="posts"> <div class="post"> <h1 class="post-title"> <a href="/2016/12/31/digital-filing/"> デジタルファイリング - データの整理整頓 </a> </h1> <span class="post-date"> 31st December 2016</span> <p>気がつけばあっというまに2016年の大晦日。昨年の大晦日も大掃除をしたり、ファイルの整理をしたりと今年は整理整頓の一年でした。</p> <p>断捨離をしつつ部屋の掃除も一段落しましたが、今年はデジタルデータの整理にも時間をかけています。デジタルデータで特に時間をかけたのが写真の整理です。昨年末から約1年かけて紙などアナログデータと、デジタルデータの整理を続けてきました。<a href="http://watermint.org/2016/06/01/manage-100k-photos-and-choice-of-storage/">10万枚を超える写真データの整理とストレージ選び</a>でもご紹介した通りNASを廃してクラウドストレージに移行しました。</p> <p>この1年試行錯誤をして、整理整頓でこだわるべきだと感じたのは次の2点でした。</p> <ul> <li>なるべく長期保存に耐えるフォーマットに統一する</li> <li>なるべく階層を減らし、フラットな構造にする</li> </ul> <p>それぞれどのようにこだわったのか紹介していきます。</p> <h1 id="section">長期保存に耐えるフォーマットへの統一</h1> <p>手元に残るうち、自分で作成した一番古いファイルのタイムスタンプを見ると1995年10月31日となっています。当時高校生でしたが、かれこれ20年以上経っています。ほとんどのファイルはまだ変換作業などすれば利用可能ですが、変換せずに閲覧できればファイルの利用価値はぐっと上がります。</p> <p>あまり古いドキュメントをいまさら変換するのは面倒ですし特にモチベーションもないのですが、最近つくったドキュメント類はPDF/XまたはPDF/Aで保存し、フォントや埋め込み画像なども含めた格好で保存するようにしています。</p> <p>ドキュメント類は上述のようにPDF/Aなどで保存していれば間違いないのですが、少し面倒なのが動画ファイルです。デジカメで撮った動画ファイルが手元にはたくさんありますが、デジカメの機種によってファイル形式はばらばらです。これらは一括で、H.264のようなに今どきの機器でプレビューしやすいフォーマットに変換しました。</p> <h2 id="section-1">紙からデジタルデータに</h2> <p>紙のデータは10年程度前から積極的にデジタルデータ化しています。クレジットカードの申込書や明細、商品を買ったときに同封されていた注意書きの紙、携帯電話やインターネットサービスの申込書や規約、購入した家電の説明書など。</p> <p>同等のデジタルデータがダウンロードできる場合には、ダウンロードして保存しておき、そうでない場合にはスキャナーをつかってPDFデータにしておきます。</p> <p>紙媒体ではサイズがまちまちだったり、大きさや重さの制約があり一ヶ所に保存するのは難しいですがデジタルデータにしてしまえばフォーマットを統一して参照することができます。</p> <p>紙媒体では契約書など現物が必要なものもありますが、デジタルデータにしておくことで、契約年月日を知りたいとか、契約の種類が何だったかといった確認のためには重宝します。</p> <h1 id="section-2">なるべく階層を減らし、フラットな構造にする</h1> <p>本屋に行くと「整理整頓」「片づけ上手」といったキーワードの本がたくさん見つかります。また、最近では「ミニマル」とか「断捨離」といったキーワードのように捨てることについて注目して説明している記事も多く見られます。</p> <p>デジタルファイリングもおそらくこの手法をそのまま採用できるだろうというのが最近の考えです。</p> <p>片づけ指南本によると基本的な考えは「よく使うものは手前に置く」というシンプルなルールであると指南されています。デジタルデータでもこれは同様です。ただ単純にフォルダ構成を考えればいいというわけではなく、仕事の進め方も同時に変えていく必要があります。</p> <h2 id="section-3">最近のファイル</h2> <p>よく使うファイルというのはほとんどん場合最近つくったファイルです。</p> <p>最近書いている記事のファイル、最近とった写真、進行中のプロジェクトといったファイルが最小の手数で開ける位置にあれば作業効率はバカにならないほど改善します。</p> <p>ですから、Macならばファインダー、Windowsならばエクスプローラーを開いてすぐにこれらのファイルやフォルダにたどり着くことができるようにします。</p> <p>こういったファイルやフォルダをデスクトップに置いている人も多いでしょう。デスクトップの使い方については少しこだわりがあるのでこちらも紹介させていただきます。</p> <h2 id="section-4">デスクトップの整理</h2> <p>個人的にはデスクトップは一時的な作業領域ととらえていて、一日の終わりに完全に空っぽの状態にしています。数年前受講したメール整理法の研修を受けました。この研修では「Inboxを毎日空っぽの状態にしましょう」という整理術を紹介していました。</p> <p>このメール整理術ではフォルダに割り振るか、TODOリストに加えるか、スケジュール帳に書き込むか、削除/アーカイブするか行き先はこの4つだけ。この狙いは、まぜこぜになった情報一覧から必要な情報を探すのにいちいち時間がかかってしまう時間ロスを減らすことにあります。</p> <p>デスクトップを空っぽにするのも同じ狙いです。たとえばプレゼンテーションスライドを作るときに大量の画像素材を準備するときは、デスクトップへ乱雑に置いていきます。ある程度情報を整理してプレゼンテーションスライドに配置が終わればスライドはプロジェクトのフォルダなどに整理しデスクトップは空っぽにします。</p> <p>もし、画像を乱雑にデスクトップへ置いたまま、別のプロジェクトの作業をデスクトップ上で始めてしまうと、どのファイルがプレゼンテーション用のものだったか探すための時間ロスが生まれます。さらにデスクトップを空っぽにするにしても、どれが不要なファイルなのか簡単に区別がつかないのでまた時間ロスがうまれたり、「念のため」ということでそのまま放置してしまうことになりがちです。</p> <h2 id="section-5">最近つくったファイルの置き場所</h2> <p>比較的よく利用する最近つくったファイルはWebサイトデザインなどの際によくいわれる「3クリックルール」を想定して整頓するとよいでしょう。チーム作業などのために、共有フォルダの構成が決まっている場合はショートカットなどを活用します。</p> <p><img src="/images/2016-12-31-finder.jpg" alt="開くフォルダの設定"/></p> <p>ファインダーであれば、ファインダーを開いた時に表示されるフォルダを設定できます。</p> <h2 id="section-6">すべてのファイルを一ヶ所に</h2> <p>ここまでは今までも似たような整理をしていたのですが、今年はNASや外付けハードディスクなどに保存していたすべてのファイルをDropboxに移行していったのでさらにファイリングを工夫しました。</p> <p>これまでバックアップのために外付けハードディスクに保存したりNASに分散管理するなどしていましたが、Dropboxに移行したことで冗長性の確保ついてはすべてDropboxに依存することにしました。これによって、同じファイルを手元で複数管理する必要がなくなったので、バックアップ頻度などバックアップ漏れがないことを意識しなくてよくなりました。</p> <p>整理を進めるに当たって、冗長管理をする必要がなくなったのは大きな進歩でした。すべてのファイルが一ヶ所にまとまっていますし、重複したファイルを持つ必要がなくなったので不要なファイルをどんどん削除することができました。ファイル数、フォルダ数が減ったことによってフォルダの見通しがよくなりました。検索も簡単です。</p> <h2 id="section-7">ファイル総量の制限</h2> <p>外付けハードディスクを利用していたときには要領あたりの単価が安いこともあって湯水のようにディスク領域を利用していました。いまはパソコンやDropboxの容量制限もありますが、主にファイル発見への時間ロスを考慮して総量制限をしています。</p> <p>ファイルが多すぎると探すための時間を使ってしまいます。ご家庭でもDeep learningなどで自動的に分類されて必要なファイルが探せる時代になればいいのですが、まだそういった使い方は先になりそうですから、時間ロスを減らすにはある程度ファイル総量を制限していくほうが理にかなっていると考えています。</p> <p>11月ごろにMacBook Proを買い替えて、内蔵SSDが1TBのモデルにしました。これはファイル総量はだいたい1TBぐらいだと時間ロスも防ぎつつ必要なファイルを保存していくためにちょうどいいのではないかなと考えたためです。</p> <p>これまでにデジカメで撮った10万枚の写真総量ではおおよそ2TB強ありました。特にNikon D800で撮影したRAWファイルは1枚当たり50MB前後とかなりの容量でした。ただ、ほとんどの写真は連射写真で個別に再利用することがなかったので、思い切ってすべて削除し、2TB強のデータを170GB程度までに削減しました。</p> <p>この制限によって、見返すことも簡単になりましたし、内蔵SSD上ですべて処理できるようになったので昔の写真を含めてすべてブラウズするといった操作もストレスなく快適になりました。</p> <h2 id="section-8">フラットに配置する</h2> <p>フォルダの見通しをさらによくするために、すべてのフォルダを3〜4クリック程度でたどり着けるように整理しました。フォルダ階層をなるべく減らしてソフトウエア等の制約で必要がない限り4階層までにおさえるようにしました。</p> <p>iPhoneやiPadなどのスマートデバイスでもたくさんタップをするよりは縦スクロールをしていくほうが簡単です。近年のパソコンでもタッチパッドなどが使いやすくなりスクロールは非常に簡単です。ですから、ファイルがフラットに並んでいるほうが階層が深くなっているよりもより目的のファイルを簡単に探すことができます。</p> <p><img src="/images/2016-12-31-flatten.jpg" alt="フォルダ階層"/></p> <p>五十音順／アルファベット順／日付順などファイルの種類におうじて工夫します。3年前から購読している新聞はすべてPDFでダウンロードができますが、新聞であれば日付順に並んでいると一目瞭然です。あまりファイルが多すぎても探しづらいので月ぐらいでフォルダを作っています。</p> <p>すべてのファイルをフラットに配置したことで、過去のファイルを参照することが日常的な作業になりました。NASや外付けハードディスクに保存していた時には、よほどの確信がなければできない作業だったのでこれは大きな変化です。</p> <h1 id="section-9">整理整頓とデジタルファイリング</h1> <p>デジタルファイリングを工夫したことで過去の情報を扱うことが簡単になりました。10年前の家計簿を見直したり、冷蔵庫の製氷機を掃除する方法を調べたり、飲み会の場で友人に3年前の旅行写真を見せたり、2年前の新聞を見直すなど一ヶ所にデジタルデータとして保存していなければなかなか面倒でした。</p> <p>この十数年でインターネットで一般的な情報を探したり、現在進行中のニュースを知ることは安価でかんたんにできるようになりました。一方で、自分にかかわる過去の情報は自分自身で整理していないとインターネット以前と同様にかんたんには探すことができません。</p> <p>今年はデジタルファイリングが一区切りついたので、来年はこれらの情報を活用する方法を研究していきます。</p> </div> <div class="post"> <h1 class="post-title"> <a href="/2016/12/15/go-bandwidth-limit-for-multilpe-io/"> Go: 複数のReader/Writerに対する帯域幅制御 </a> </h1> <span class="post-date"> 15th December 2016</span> <p>ネットワークやディスクへの読み書き処理の際、帯域幅制御をしたい場合があります。低優先度の処理などによって主となるビジネスロジックが阻害されないよう制御するといった目的や、一つのサーバ資源で複数のサービスを提供するときに一つのサービスが資源を消費しすぎないようにしたいといった目的があります。</p> <p>Goでこのような処理を書きたいとき、ざっと調べてみたところ<a href="https://github.com/mxk/go-flowrate">go-flowrate</a>という実装が見つかりました。</p> <div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">f</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"data.dat"</span><span class="p">)</span><span class="x">

    </span><span class="c">// 100バイト/秒の帯域幅制御付きのラッパーをつくる</span><span class="x">
    </span><span class="n">f2</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">flowrate</span><span class="o">.</span><span class="n">NewReader</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="x"> </span><span class="m">100</span><span class="p">)</span><span class="x">

    </span><span class="c">// 実際の処理</span><span class="x">
    </span><span class="c">// ...</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre> </div> <p>使い方もシンプルできっちり制御できるのでこれでいいのですが、制御できるのが一つの<code class="highlighter-rouge">io.Reader</code>または<code class="highlighter-rouge">io.Writer</code>のみに対してのみ可能で、複数の<code class="highlighter-rouge">io.Reader</code>や<code class="highlighter-rouge">io.Writer</code>に対しては制御することができません。</p> <p>並列処理が必要なプログラムを書いているとちょっとこれではそのまま使えそうにありません。もう少しほかの選択肢を探してもよいのですが、ちょうどいいGoのプログラミング課題ということで新しく実装してみることにしました。</p> <h1 id="section">出来上がり</h1> <p>まずはでき上がったライブラリを紹介します。<a href="https://github.com/watermint/bwlimit">bwlimit</a>としてGithub上に公開してあります。利用例は次のようなイメージです。</p> <div class="language-go highlighter-rouge"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// 100バイト/秒に制限</span><span class="x">
    </span><span class="n">bwlimit</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">NewBwlimit</span><span class="p">(</span><span class="m">100</span><span class="p">,</span><span class="x"> </span><span class="no">false</span><span class="p">)</span><span class="x">

    </span><span class="c">// 複数のReader</span><span class="x">
    </span><span class="n">f1</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"data1.dat"</span><span class="p">)</span><span class="x">
    </span><span class="n">f2</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"data2.dat"</span><span class="p">)</span><span class="x">

    </span><span class="c">// ラッパーを作成</span><span class="x">
    </span><span class="n">fr1</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bwlimit</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="x">
    </span><span class="n">fr2</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">bwlimit</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span><span class="x">

    </span><span class="c">// 実際の処理</span><span class="x">
    </span><span class="c">// ...</span><span class="x">

    </span><span class="c">// すべてのReaderがClose()されるかEOFになるまで待機</span><span class="x">
    </span><span class="n">bwlimit</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre> </div> <p>まずは帯域幅制御を制御するオブジェクト(上図では<code class="highlighter-rouge">bwlimit</code>)を作り、さらにそれぞれラッパーを作成します。<code class="highlighter-rouge">NewBwlimit</code>の第二引数は帯域幅制限しているときRead/Write処理を待たせるかどうかです。</p> <p>あとはラッパーを普通の<code class="highlighter-rouge">io.Reader</code>として扱うだけです。並列処理をしていて、すべてのReaderまたはWriterについて処理が完了したかどうか知りたくなったので待機する<code class="highlighter-rouge">Wait()</code>もつくりました。</p> <h1 id="section-1">仕組み</h1> <p>キューを作る方法などいくつか実装方法を検討しましたが最終的にはかなりシンプルな構造になりました。トヨタ生産方式の本を思い出してヒントを得ました。</p> <p><a href="https://ja.wikipedia.org/wiki/%E3%82%BF%E3%82%AF%E3%83%88%E3%82%BF%E3%82%A4%E3%83%A0">タクトタイム</a>という一定時間のリズムを刻んで、各拍子のタイミングで利用可能な帯域を現在有効なReader/Writerで分割して利用するアイデアです。</p> <p>たとえばタクトタイムを1秒間に10回に設定したとします。帯域幅設定を1000バイト/秒にした場合、タクトタイム1回あたりに利用可能な帯域幅は100バイトです。有効なReaderが2つであればこの100バイトをわけあって、50バイトずつの読み取りを許可する枠を設定します。実際に、Reader側が読み取るかどうかはわかりませんが、読み取り可能な上限を制御することでこのような流量制御を行っています。</p> <h1 id="section-2">流量制御と障害防止</h1> <p>あるタクトタイムのときに、読み取りが実際に発生せず50バイト分の枠がまるまるある状態で、次のタクトタイムになったとき読み取り可能枠を50 + 50バイト分にはしないようにしました。流量はこれによってすこし減ってしまいますが、意図しない障害を防ぐためです。</p> <p>読み取り可能枠が溜まりにたまって一気に転送が行われてしまうと、他のサービスへ影響がでることはもちろん、場合によってはルーターなどのバッファサイズを超えるなどして障害が発生することも考えられます。</p> <h1 id="section-3">利用例</h1> <p>また別の記事として各予定ですが、Dropboxへのファイルアップローダーをいま作っています。このファイルアップローダーで並列してファイルのアップロードをする際に、帯域幅制御をつけたかったのがこのライブラリ作成のモチベーションです。</p> </div> <div class="post"> <h1 class="post-title"> <a href="/2016/12/14/dmg-and-cli-en/"> Disk image file (.dmg) from command line </a> </h1> <span class="post-date"> 14th December 2016</span> <p>I prefer .dmg instaed of zip for archiving project data, etc. <code class="highlighter-rouge">.dmg</code> is handy for refering files, modify contents without extract files to somewhere.</p> <p><code class="highlighter-rouge">.dmg</code> can usable as like USB drive. Disk Utility tool can create/update <code class="highlighter-rouge">.dmg</code> from folder with various options. Options are like encryption, readonly, compression, etc.</p> <p>But if you have tens of folders to archive, it’s better to use command line tools.</p> <h2 id="create-encrypted-dmg-file">Create encrypted <code class="highlighter-rouge">.dmg</code> file</h2> <p><code class="highlighter-rouge">hdiutil</code> is command line version of Disk Utility app. This command can mount/unmount/create/update disk image files. Please see <code class="highlighter-rouge">man hdiutil</code> for more detail.</p> <p>Below script is part of my workflow of archiving project files. I’m using encrypted <code class="highlighter-rouge">.dmg</code> for archive. The script require prepare password file under <code class="highlighter-rouge">$HOME/.dmg-password</code>. Please create and store password for <code class="highlighter-rouge">.dmg</code> without LF.</p> <p>And update permission like <code class="highlighter-rouge">chmod 600 $HOME/.dmg-password</code> to prevent read from other users. This sequence using password and encryption. But it’s not strong enough, reason described below.</p> <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>-lt 2 <span class="o">]</span>; <span class="k">then
  </span><span class="nb">echo</span> <span class="nv">$0</span> SRC_DIR DEST_DIR
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">SRC</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">DST</span><span class="o">=</span><span class="nv">$2</span>
<span class="nv">PWD</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/.dmg-password"</span>

<span class="k">if</span> <span class="o">[</span> ! -e <span class="nv">$PWD</span> <span class="o">]</span>; <span class="k">then
  </span><span class="nb">echo </span>Disk Image password not found
  <span class="nb">exit </span>2
<span class="k">fi

for </span>t <span class="k">in</span> <span class="s2">"</span><span class="nv">$SRC</span><span class="s2">"</span>/<span class="k">*</span>; <span class="k">do
  if</span> <span class="o">[</span> -d <span class="s2">"</span><span class="nv">$t</span><span class="s2">"</span> <span class="o">]</span>; <span class="k">then
    </span><span class="nb">echo </span>Creating: <span class="nv">$t</span>
    <span class="nv">n</span><span class="o">=</span><span class="k">$(</span>basename <span class="nv">$t</span><span class="k">)</span>
    cat <span class="nv">$PWD</span> |                <span class="se">\</span>
      hdiutil create          <span class="se">\</span>
        -srcfolder <span class="s2">"</span><span class="nv">$t</span><span class="s2">"</span>       <span class="se">\</span>
        -fs HFS+              <span class="se">\</span>
        -encryption AES-128   <span class="se">\</span>
        -format UDBZ          <span class="se">\</span>
        -stdinpass            <span class="se">\</span>
        <span class="s2">"</span><span class="nv">$DST</span><span class="s2">/</span><span class="nv">$n</span><span class="s2">.dmg"</span>
  <span class="k">fi
done</span>
</code></pre> </div> <h2 id="preset-password-for-dmg-in-key-chain">Preset password for <code class="highlighter-rouge">.dmg</code> in Key Chain</h2> <p>It’s kind of pain in neck entering password for opening <code class="highlighter-rouge">.dmg</code> everytime. If you open <code class="highlighter-rouge">.dmg</code> from Finder.app, the password dialog refuse copy &amp; paste operation.</p> <p><img src="/images/2016-12-13-dmg1.png" alt="Password dialog"/></p> <p>There is option “remember password in my keychain”. Concept is similar to this.</p> <p>The password for disk image is stored in keychain which identified by UUID of <code class="highlighter-rouge">.dmg</code>. The UUID is referable by command like below.</p> <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>hdiutil isencrypted YOURDISKIMAGE.dmg
</code></pre> </div> <p>Now you can store password through <code class="highlighter-rouge">security</code> command.</p> <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>security add-generic-password -a <span class="o">(</span>UUID above<span class="o">)</span> -D <span class="s2">"disk image password"</span> -s <span class="o">(</span>YOUR DISK IMAGE<span class="o">)</span>.dmg -w <span class="o">(</span>PASSWORD OF DISK IMAGE<span class="o">)</span>
</code></pre> </div> <p>Unfortunatelly, there are no option like <code class="highlighter-rouge">-stdinpass</code>. So the password must be passed through command line argument. This mean optential leak through <code class="highlighter-rouge">ps</code> command or shell history.</p> <p>By the way, I’m using below script for preset password to disk images.</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>-lt 1 <span class="o">]</span>; <span class="k">then
  </span><span class="nb">echo</span> <span class="nv">$0</span> <span class="o">[</span>dmg file]...
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">PWD</span><span class="o">=</span><span class="nv">$HOME</span>/.dmg-password

<span class="k">for </span>FILE <span class="k">in</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>; <span class="k">do
  </span><span class="nv">UUID</span><span class="o">=</span><span class="k">$(</span>hdiutil isencrypted <span class="s2">"</span><span class="nv">$FILE</span><span class="s2">"</span> 2&gt;&amp;1 | grep uuid | awk <span class="s1">'{print $2}'</span><span class="k">)</span>
  <span class="nv">BASE</span><span class="o">=</span><span class="k">$(</span>basename <span class="nv">$FILE</span><span class="k">)</span>

  <span class="nb">echo </span>File: <span class="nv">$BASE</span>
  <span class="nb">echo </span>UUID: <span class="nv">$UUID</span>

  security add-generic-password -a <span class="nv">$UUID</span> -D <span class="s2">"disk image password"</span> -s <span class="nv">$BASE</span> -w <span class="k">$(</span>cat <span class="nv">$PWD</span><span class="k">)</span>
<span class="k">done</span>
</code></pre> </div> <p>When opening <code class="highlighter-rouge">.dmg</code> from Finder, operating system ask authorisation of using password by <code class="highlighter-rouge">diskimages-helper</code>.</p> <p><img src="/images/2016-12-13-dmg2.png" alt="Confirmation dialog"/></p> <p>You can skip this dialog by <code class="highlighter-rouge">-A</code> option of <code class="highlighter-rouge">security</code> command, but this option authorise for all applications. It’s better not use this <code class="highlighter-rouge">-A</code> option for better security.</p> </div> <div class="post"> <h1 class="post-title"> <a href="/2016/12/13/dmg-and-cli/"> ディスクイメージファイル(.dmg)をコマンドラインから </a> </h1> <span class="post-date"> 13th December 2016</span> <p>Macでたくさんのファイルをひとまとめにするのであればzipで圧縮するよりも、ディスクイメージファイルにしたほうが便利なこともあります。zipだと標準では中身を確認するのに毎回どこかに展開しないといけないですし、ファイルの内容を変更するのも面倒です。zip用のツールを使えばおそらくそれらも解決できると思いますが、個人的にはディスクイメージファイル(.dmg)を使うことの方が多いです。</p> <p>ディスクイメージファイルは外付けディスクのようなイメージでマウントして使えます。macOSに標準添付されている「ディスクユーティリティー」ツールを使えばこのイメージファイルを簡単に作ることができます。読み取り専用、読み書き可能、暗号化、圧縮などオプションを選ぶこともできます。</p> <p>終了したプロジェクトのファイル一式は.dmgファイルとしてまとめていますが、まとめたいプロジェクトファイルがたくさんあったり、ワークフローを自動化したいとなってくるとコマンドライン操作を覚えると便利です。</p> <h2 id="section">ディスクイメージファイルの作成</h2> <p><code class="highlighter-rouge">hdiutil</code>コマンドを使うとディスクイメージファイルの作成や設定変更、ディスクイメージファイルのマウント、アンマウントなどさまざま操作可能です。詳しくは<code class="highlighter-rouge">man hdiutil</code>をご参照いただくとして手元での利用例をご紹介します。</p> <p>フォルダ以下にあるサブフォルダをそれぞれ<code class="highlighter-rouge">.dmg</code>として一括変換したい場合に使っているスクリプトです。それぞれ一応暗号化しておこうということで、暗号化用のパスワードを<code class="highlighter-rouge">$HOME/.dmg-password</code>というファイルにあらかじめ格納してあります。パスワードファイルには最後に改行が入らないようにつくっておいてください。</p> <p>あとパーミッションも <code class="highlighter-rouge">chmod 600 $HOME/.dmg-password</code>など他者から読み出せないようにしておきます。そうはいっても、後述しますが一連のプロセスはさほど安全性が高いわけではありませんので「添付ファイルはパスワードつきzipでパスワードは別メールですぐ送信!」とあまり変わらないセキュリティーレベルとお考えいただいていいかと思います。</p> <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>-lt 2 <span class="o">]</span>; <span class="k">then
  </span><span class="nb">echo</span> <span class="nv">$0</span> SRC_DIR DEST_DIR
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">SRC</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">DST</span><span class="o">=</span><span class="nv">$2</span>
<span class="nv">PWD</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/.dmg-password"</span>

<span class="k">if</span> <span class="o">[</span> ! -e <span class="nv">$PWD</span> <span class="o">]</span>; <span class="k">then
  </span><span class="nb">echo </span>Disk Image password not found
  <span class="nb">exit </span>2
<span class="k">fi

for </span>t <span class="k">in</span> <span class="s2">"</span><span class="nv">$SRC</span><span class="s2">"</span>/<span class="k">*</span>; <span class="k">do
  if</span> <span class="o">[</span> -d <span class="s2">"</span><span class="nv">$t</span><span class="s2">"</span> <span class="o">]</span>; <span class="k">then
    </span><span class="nb">echo </span>Creating: <span class="nv">$t</span>
    <span class="nv">n</span><span class="o">=</span><span class="k">$(</span>basename <span class="nv">$t</span><span class="k">)</span>
    cat <span class="nv">$PWD</span> |                <span class="se">\</span>
      hdiutil create          <span class="se">\</span>
        -srcfolder <span class="s2">"</span><span class="nv">$t</span><span class="s2">"</span>       <span class="se">\</span>
        -fs HFS+              <span class="se">\</span>
        -encryption AES-128   <span class="se">\</span>
        -format UDBZ          <span class="se">\</span>
        -stdinpass            <span class="se">\</span>
        <span class="s2">"</span><span class="nv">$DST</span><span class="s2">/</span><span class="nv">$n</span><span class="s2">.dmg"</span>
  <span class="k">fi
done</span>
</code></pre> </div> <h2 id="keychain">ディスクイメージファイルのパスワードをKeyChainにプリセットしておく</h2> <p>暗号化しておいたのはいいですが、作成したディスクイメージファイルを開く際にいちいちパスワードを入力するのは面倒です。Finderからダブルクリックしてマウントしようとしたときに聞かれるパスワードダイアログはコピー&amp;ペーストを受け入れてくれないというのもさらに面倒さを増しています。</p> <p><img src="/images/2016-12-13-dmg1.png" alt="パスワードダイアログ"/></p> <p>パスワードをキーチェインに記憶させるというオプションがありますが、あらかじめコマンドラインから記憶させておけばいいという発想です。</p> <p>ディスクイメージファイルに対するパスワードは一般パスワードとして各ディスクイメージファイルのUUIDと対応して管理されています。このUUIDは</p> <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>hdiutil isencrypted ディスクイメージファイル.dmg
</code></pre> </div> <p>というように<code class="highlighter-rouge">isencrypted</code>オプションで知ることができます。キーチェインにパスワードを追加するには</p> <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>security add-generic-password -a <span class="o">(</span>上記のUUID<span class="o">)</span> -D <span class="s2">"disk image password"</span> -s <span class="o">(</span>ファイル名<span class="o">)</span>.dmg -w <span class="o">(</span>パスワード<span class="o">)</span>
</code></pre> </div> <p>というように実行すればよいでしょう。<code class="highlighter-rouge">security</code>コマンドの大変残念な点は<code class="highlighter-rouge">hdiutil</code>の<code class="highlighter-rouge">-stdinpass</code>のように標準入力からパスワードを受け取る手段がどうやらなさそうな点です。</p> <p>コマンド引数として実行してしまうと、シェルの履歴に残ったり、<code class="highlighter-rouge">ps</code>コマンドなどでパスワードが漏えいしてしまうケースがあります。このような点から上述のように「添付ファイルはパスワードつきzipでパスワードは別メールですぐ送信!」というセキュリティーレベルとたいして変わらないと思っています。</p> <p>さて、上記を合わせて次のようなスクリプトにしてあります。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>-lt 1 <span class="o">]</span>; <span class="k">then
  </span><span class="nb">echo</span> <span class="nv">$0</span> <span class="o">[</span>dmg file]...
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">PWD</span><span class="o">=</span><span class="nv">$HOME</span>/.dmg-password

<span class="k">for </span>FILE <span class="k">in</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>; <span class="k">do
  </span><span class="nv">UUID</span><span class="o">=</span><span class="k">$(</span>hdiutil isencrypted <span class="s2">"</span><span class="nv">$FILE</span><span class="s2">"</span> 2&gt;&amp;1 | grep uuid | awk <span class="s1">'{print $2}'</span><span class="k">)</span>
  <span class="nv">BASE</span><span class="o">=</span><span class="k">$(</span>basename <span class="nv">$FILE</span><span class="k">)</span>

  <span class="nb">echo </span>File: <span class="nv">$BASE</span>
  <span class="nb">echo </span>UUID: <span class="nv">$UUID</span>

  security add-generic-password -a <span class="nv">$UUID</span> -D <span class="s2">"disk image password"</span> -s <span class="nv">$BASE</span> -w <span class="k">$(</span>cat <span class="nv">$PWD</span><span class="k">)</span>
<span class="k">done</span>
</code></pre> </div> <p>このようにキーチェインにパスワードを設定したファイルを開こうとすると次のようにキーチェインからパスワードを取り出していいか確認されます。</p> <p><img src="/images/2016-12-13-dmg2.png" alt="確認ダイアログ"/></p> <p>このダイアログを<code class="highlighter-rouge">security</code>コマンドの<code class="highlighter-rouge">-A</code>オプションでスキップする手段もありますがすべてのアプリケーションに対して許可を出してしまいます。少し面倒ですが、ここは一手間かけておいたほうがいいでしょう。</p> </div> <div class="post"> <h1 class="post-title"> <a href="/2016/12/12/tumblr-to-jekyll/"> TumblrからJekyll + Github Pagesへ </a> </h1> <span class="post-date"> 12th December 2016</span> <p><a href="/2013/08/24/wordpress-to-tumblr">3年ほど前にWordPressからTumblrへ移行しました</a>。特に大きな問題があったわけではないのですが、最近ソースコードを挿入した記事をいくつか書こうとしたところTumblrのMarkdownではうまく表現され切れない点にすこしストレスを感じていました。表示をあれこれいじっている時間ももったいなくなってきたのでいっそのこと、<a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown">GFM (GitHub Flavored Markdown)</a>で書けるようなサービスか、システムに移行しようと考え始めました。</p> <p>あれこれ調べているうちに、どうやら<a href="https://jekyllrb.com/">Jekyll</a>をつかって<a href="https://pages.github.com/">Github Pages</a>へ移行するのがスムーズそうだなと調べ始めて評価し、次の点で問題なさそうだったので移行することにしました。</p> <ul> <li>GFMで書ける</li> <li>既存のURL構成を引き継げる</li> <li>Tumblrからの記事取り込みもできる</li> <li>シンプルなテーマがある</li> </ul> <p>逆に移行に当たってできなくなる機能もあります。たとえばソーシャルメディア連携です。Tumblrでホストしてもらえば、Tumblr上のソーシャルメディアでリブログなど拡散手段があります。ほかには予約投稿やTwitter連携といった機能も使えなくなります。このあたりはトレードオフですが、ソーシャルメディアで拡散していただくよりも、そもそも記事が書きづらくて筆無精になるのであれば優先順位は明らかです。</p> <p>ソーシャルメディア連携もあとからIFTTTなど何か使えば実現できるでしょうし、予約投稿も必要になれば決まった時間に<code class="highlighter-rouge">git push</code>するよう何か構成を考えればいいだけです。</p> <h1 id="section">移行の効果</h1> <p>移行中のあれこれは後述することにしてまずは、移行によってどういったメリットがあったかみてみます。</p> <p>WordPressから移行した際にはサイトの速度が劇的に改善しましたが、今回は比較的軽微な差に収まっています。</p> <h2 id="tumblrpagespeed">TumblrでのPageSpeed結果</h2> <p>まずはTumblrでの<a href="https://developers.google.com/speed/pagespeed/">PageSpeed</a>計測結果から。</p> <p><img src="/images/2016-12-12-tumblr-mobile.png" alt="Tumblr / モバイル"/></p> <p>モバイル用のスコアは67点。画像サイズが大きいと警告がでているのと、キャッシュ設定などのところで最適化の余地があるとの判定です。</p> <p><img src="/images/2016-12-12-tumblr-desktop.png" alt="Tumblr / デスクトップ"/></p> <p>デスクトップ用のスコアは77点。モバイルと同様に画像が大きいと警告が出ています。いずれにしても体感的にはもっさりした感覚は全くなく、表示速度などの不満は特にありませんでした。</p> <h2 id="jekyll--github-pagespagespeed">Jekyll + Github PagesでPageSpeed結果</h2> <p><img src="/images/2016-12-12-jekyll-mobile.png" alt="Jekyll + Github Pages / モバイル"/></p> <p>モバイル用のスコアは72点と少しだけTumblrでの表示より改善しています。これはTumblrのインフラスピードとの差というよりは、採用しているテーマのCSSやJavaScriptの差がほとんどだと考えられます。</p> <p><img src="/images/2016-12-12-jekyll-desktop.png" alt="Jekyll + Github Pages / デスクトップ"/></p> <p>デスクトップ用のスコアは77点とTumblrでの結果と同じです。</p> <h2 id="section-1">その他の違い</h2> <p>Tumblrではモバイル対応していないテーマを使っていたので、TumblrのUIが優先して表示されています。一方、Jekyllで今回利用した<a href="http://lanyon.getpoole.com/">Lanyon</a>はモバイルフレンドリーなテーマで、今回どちらでも同じLook and Feelでサイトを表示できるようになりました。</p> <h1 id="section-2">移行</h1> <p>移行作業はJekyllの使い方を覚えるところから全部でおおよそ5〜6時間かかったかと思います。Jekyllはかなり活発に開発されているようなのであまりここで細々と手順を書いてもすぐ使いもにならなくなってしまう気がするのでおおまかな流れだけご紹介しておきます。</p> <h2 id="jekyll">Jekyll環境の設定</h2> <p>最近はこの手のツールを使うときはすべてDockerを使って独立した環境で実行するようにしています。再現性もありますし、手元の環境もシンプルに保てます。Jekyllを使うには既存のDockerイメージを使えば充分ですが、いくつかテーマを試したりしているうちに依存関係のあるライブラリをまとめてイメージとして持っていたほうが便利だったので次のような内容の<code class="highlighter-rouge">Dockerfile</code>を作っています。</p> <div class="highlighter-rouge"><pre class="highlight"><code>FROM jekyll/jekyll:builder

RUN apk add --no-cache --virtual build-dependencies build-base
RUN apk add --no-cache libxml2-dev libxslt-dev
RUN apk add --no-cache ruby-dev curl-dev zlib-dev yaml-dev
RUN gem install nokogiri
RUN gem install minima
RUN gem install jekyll-import
</code></pre> </div> <p><code class="highlighter-rouge">jekyll-import</code>は後述のTumblrから記事を取り込んだときに使ったものです。この<code class="highlighter-rouge">Dockerfile</code>をビルドしておきます。たとえば<code class="highlighter-rouge">site</code>ディレクトリ以下につくっていくならこんな感じにコンテナを実行して、テンプレートを作ったり<code class="highlighter-rouge">jekyll-import</code>を実行したりできます。</p> <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>docker run --rm -i <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/site:/srv/jekyll -p 4000:4000 -t <span class="o">(</span>ビルドしたときのタグ名<span class="o">)</span> bash
</code></pre> </div> <p>今回はあれこれテーマをダウンロードし、<code class="highlighter-rouge">jekyll-import</code>でTumblrから記事をざっくり取り込んで表示確認をしながらレイアウトを決定しました。</p> <h2 id="tumblr">Tumblrからのインポート</h2> <p><a href="http://import.jekyllrb.com/docs/tumblr/">jekyll-importのTumblrについての記事</a>にコマンドが書かれていますのでこれを実行します。 移行といっても今回はTumblrで書いた記事が12記事しかなかったので、ある程度の部分は詳しく調べずに手作業でファイルを修正していくというスタイルで解決しました。</p> <p>今回実行した際は次のように実行しました。</p> <div class="language-sh highlighter-rouge"><pre class="highlight"><code>ruby -rubygems -e <span class="s1">'require "jekyll-import";
    JekyllImport::Importers::Tumblr.run({
      "url"            =&gt; "http://(TumblrのID).tumblr.com",
      "format"         =&gt; "html",
      "grab_images"    =&gt; true,
      "add_highlights" =&gt; true,
      "rewrite_urls"   =&gt; true
    })'</span>
</code></pre> </div> <p>最初formatはMarkdown(md)を指定していましたが、うまく記事が取りこめなかったのでhtmlで取り込み、あとで手動でMarkdownに変換しました。</p> <p>Tumblrでは記事のURLが <code class="highlighter-rouge">/post/(記事ID)/(記事タイトル)</code>というフォーマットでしたが、Jekyllでは<code class="highlighter-rouge">/(年)/(月)/(日)/(記事タイトル)</code>となるので変換が必要です。<code class="highlighter-rouge">rewrite_urls</code>で相当するアドレスにリダイレクトするファイルを作ってくれるので、リンクはそのまま維持できます。</p> <p>ただ困ったことに生々されたリダイレクト用の<code class="highlighter-rouge">index.html</code>では<code class="highlighter-rouge">/(年)-(月)-(日)-(記事タイトル)</code>へのリダイレクトになっていてうまく動きません。あれこれ探すのも面倒だったのでここは手動で直してしまいました。</p> <p><code class="highlighter-rouge">grab_images</code>という設定があり画像をもってきてくれそうな印象がありましたが、これもうまく動かなかったので手作業で画像をもってきたり、手元に保存してあったものを使ったりして再構成しました。</p> <h2 id="section-3">テーマ選び</h2> <p>いくつかサンプルを見ながら選びましたがシンプルなものがよかったのでLanyonにしました。ほかにもシンプルなデザインのものはありましたが、Lanyonは欲しい機能がおおむね入っていることと、CSSやJavaScriptを含めても全体の構成がシンプルで全体が見渡しやすいことが気に入りました。</p> <h1 id="section-4">切り替え</h1> <p>できあがったJekyllのページ一式をGithub Pagesへプッシュし、あとはCloudFlareでDNSの切り替えをすれば終了です。</p> <p>Jekyllも開発スピードが速そうなので、開発についていくとしたらかなり大変そうです。ただでき上がったサイトはかなりシンプルなHTML、CSS、JavaScriptと画像ファイルだけで構成されているのでセキュリティー上の理由などで更新しなければいけないケースはかなり少ないと思います。</p> <p>そういった意味では、一度環境ができ上がってしまえばTumblrでプレビューにあれこれ悩みながら記事を書くよりも手元の環境で確実なプレビューを見てから公開できるワークフローをつくったほうがより生産性が高そうだということで今は満足しています。</p> <p>画像を含めたオーサリングのワークフローをつくったり、プレビューから予定投稿などまでいろいろ作り込みたいところですがそのあたりはまた今度じっくり作り込んでみることにします。</p> </div> </div> <div class="pagination"> <a class="pagination-item older" href="/page2">Older</a> <span class="pagination-item newer">Newer</span> </div> </div> <div class="container copyright"> &copy; 2005-2017 Takayuki Okazaki </div> </div> <label for="sidebar-checkbox" class="sidebar-toggle"></label> <script>!function(e){var c=e.querySelector(".sidebar-toggle"),r=e.querySelector("#sidebar"),t=e.querySelector("#sidebar-checkbox");e.addEventListener("click",function(e){var n=e.target;t.checked&&!r.contains(n)&&n!==t&&n!==c&&(t.checked=!1)},!1)}(document);</script> <script>!function(e,t,a,n,c,s,o){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,s=t.createElement(a),o=t.getElementsByTagName(a)[0],s.async=1,s.src=n,o.parentNode.insertBefore(s,o)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-769616-6","auto"),ga("send","pageview");</script> </body> </html>